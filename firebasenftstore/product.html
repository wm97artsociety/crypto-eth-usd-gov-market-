<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Product Details - Universal Crypto Marketplace</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: #f4f4f4; }
    .top-bar { background: #222; color: white; padding: 10px 20px;
      display: flex; justify-content: space-between; align-items: center; }
    .wallet-controls { display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
    .connect-btn { background: #0073e6; color: white; }
    .connect-btn:hover { background: #005bb5; }
    #adminBtn { background: #0073e6; color: white; display: none; }
    #adminBtn:hover { background: #005bb5; }
    #contactBtn { background: #f39c12; color: white; }
    #contactBtn:hover { background: #e67e22; }
    .home-btn { background: #4CAF50; color: white; }
    .home-btn:hover { background: #45a049; }
    .wallet-controls button {
      padding: 8px 12px; border-radius: 4px; border: none;
      cursor: pointer; width: 100%;
    }

    /* Main layout container */
    .main-product-layout {
        display: flex;
        flex-wrap: wrap; /* Allow wrapping */
        justify-content: center;
        padding: 40px;
        gap: 20px; /* Space between the two main columns */
    }

    /* Container for product info and reviews (left column) */
    .product-info-and-reviews {
        display: flex;
        flex-direction: column; /* Stack product detail and reviews vertically */
        width: 60%; /* Allocate width for this column */
        min-width: 300px; /* Minimum width before wrapping */
        gap: 20px; /* Space between product detail and review sections */
    }

    /* Product Detail Styles (within the left column) */
    .product-detail {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        width: 100%; /* Take full width within its column */
    }
    .product-detail img { max-width: 100%; border-radius: 6px; margin-bottom: 20px; }
    .product-detail h3 { font-size: 24px; margin-bottom: 15px; color: #333; }
    .product-detail p { font-size: 16px; color: #666; margin-bottom: 15px; }
    .product-detail .price { font-size: 22px; color: #0073e6; margin-bottom: 20px; }

    /* Review Section Styles (within the left column, below product detail) */
    .review-section {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        width: 100%; /* Take full width within its column */
        /* Removed margin-top, padding-top, border-top as it's now integrated visually */
    }
    .review-section h3 {
        font-size: 24px;
        margin-bottom: 15px;
        color: #333;
        border-bottom: 2px solid #ffc107; /* Yellow border for reviews */
        padding-bottom: 10px;
    }
    .average-rating {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        font-size: 1.5em;
        color: #ffc107; /* Yellow color for stars */
    }
    .average-rating .stars {
        margin-right: 10px;
    }
     .average-rating .stars i {
         color: #ffc107; /* Ensure stars are yellow */
     }
    .average-rating .score {
        font-weight: bold;
        margin-right: 5px;
        color: #333; /* Darker color for the score */
    }
    .average-rating .count {
        font-size: 0.8em;
        color: #555;
    }

    .recent-reviews h4 {
        font-size: 20px;
        margin-bottom: 15px;
        color: #333;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }
    #recentReviewsList {
        list-style: none;
        padding: 0;
    }
    #recentReviewsList li {
        border: 1px solid #eee;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 8px;
        background-color: #f9f9f9;
    }
     #recentReviewsList li:last-child {
         margin-bottom: 0; /* Remove bottom margin on the last item */
     }
     #recentReviewsList li .review-header {
         display: flex;
         justify-content: space-between;
         align-items: center;
         margin-bottom: 10px;
     }
      #recentReviewsList li .review-header .reviewer {
          font-weight: bold;
          color: #0073e6; /* Blue color for reviewer */
      }
       #recentReviewsList li .review-header .review-date {
           font-size: 0.9em;
           color: #777;
       }
     #recentReviewsList li .review-rating i {
         color: #ffc107; /* Yellow color for review stars */
         font-size: 1em; /* Standard size for individual review stars */
     }
    #recentReviewsList li p {
        margin: 0;
        color: #444;
    }
     .no-reviews-message {
         font-style: italic;
         color: #777;
     }


    /* Order Form Styles (right column) */
    .order-form {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        width: 30%; /* Allocate width for the order form */
        min-width: 280px; /* Minimum width before wrapping */
        /* Removed margin-top as it's now part of the flex gap */
    }
    .order-form h3 { font-size: 24px; margin-bottom: 15px; color: #333; }
    .order-form label { display: block; margin-top: 10px; color: #444; }
    .order-form input[type="text"],
    .order-form input[type="number"] {
      width: 100%; padding: 10px; margin-top: 5px;
      font-size: 16px;
	border: 1px solid #ddd; border-radius: 5px;
    }
     .order-form input[type="checkbox"] {
         width: auto; /* Allow checkbox to be its natural size */
         margin-right: 5px; /* Space between checkbox and label */
         vertical-align: middle; /* Align checkbox vertically with text */
         display: inline-block; /* Ensure checkbox is inline */
     }
     .order-form label.checkbox-label {
         display: inline-block; /* Display label next to checkbox */
         font-weight: normal; /* Normal weight for the label text */
         margin-bottom: 10px; /* Space below the checkbox/label */
         vertical-align: middle; /* Align label vertically with checkbox */
         cursor: pointer; /* Indicate it's clickable */
     }
     /* Style for the info icon */
     .info-icon {
         cursor: pointer;
         color: #0073e6; /* Blue color for the icon */
         margin-left: 5px;
         vertical-align: middle; /* Align icon vertically */
     }
      .info-icon:hover {
          color: #005bb5; /* Darker blue on hover */
      }


    .order-form button {
      background: #0073e6;
	color: white; padding: 12px; border: none;
      border-radius: 5px; cursor: pointer; width: 100%; margin-top: 15px;
    }
    .order-form button:hover { background: #005bb5; }
    /* Style for alternative payment buttons */
    .order-form .alt-pay-button {
        background-color: #555; /* Neutral background */
        color: white;
        padding: 12px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px; /* Add some space above */
    }
    .order-form .alt-pay-button:hover {
        background-color: #777;
    }

    /* Specific styles for branding */
    #payWithVenmoBtn { background-color: #008CFF; }
    #payWithVenmoBtn:hover { background-color: #0077E6; }
    #payWithCashAppBtn { background-color: #00C400; }
    #payWithCashAppBtn:hover { background-color: #00A300; }
    #payWithPaypalBtn { background-color: #003087; }
    #payWithPaypalBtn:hover { background-color: #002669; }
    #payWithApplePayBtn { background-color: #000000; } /* Apple Pay typically uses black */
    #payWithApplePayBtn:hover { background-color #333333; }
     /* Style for Google Pay button */
     #payWithGooglePayBtn {
         background-color: #4285F4; /* Google blue */
         color: white;
     }
      #payWithGooglePayBtn:hover {
          background-color: #357ae8; /* Darker blue on hover */
      }


    /* Style for the market fee text */
    .market-fee-text {
        font-size: 0.9em;
        color: #555;
        margin-top: 5px; /* Adjust spacing as needed */
        margin-bottom: 15px; /* Space before the next button */
        display: none; /* Hidden by default */
    }

    /* Style for the Payment Methods section separation */
    .payment-methods-section {
        margin-top: 20px; /* Space above the section */
        padding-top: 20px; /* Space inside the section */
        border-top: 1px solid #ddd; /* Add a line to separate */
    }
     .payment-methods-section h3 {
         margin-top: 0; /* Remove top margin from the heading */
     }

    /* Responsive layout adjustments */
    @media (max-width: 768px) {
        .main-product-layout {
            flex-direction: column; /* Stack all sections vertically */
            padding: 20px;
            gap: 20px; /* Restore gap between stacked sections */
        }
        .product-info-and-reviews,
        .product-detail,
        .review-section,
        .order-form {
            width: 100%; /* Make all sections take full width */
            min-width: auto;
            /* Reset margins/padding/borders if they were adjusted for column layout */
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }
         .product-info-and-reviews {
             gap: 20px; /* Restore gap between product detail and reviews when stacked */
         }
          /* Add back separation borders/margins for stacked layout */
         .review-section {
             margin-top: 20px;
             padding-top: 20px;
             border-top: 1px solid #ddd;
         }
         .order-form {
             margin-top: 0; /* Gap is handled by main-product-layout */
         }
    }


    footer { text-align: center; padding: 20px;
	background: #222; color: white; margin-top: 50px; }
  </style>
</head>
<body>
<div class="top-bar">
  <h1>🌎 Universal Crypto Marketplace</h1>
  <div class="wallet-controls">
    <span id="walletDisplay">Wallet: —</span>
    <button id="connectBtn" class="connect-btn">🔌 Connect Wallet</button>
    <button id="adminBtn" onclick="window.location.href='admin.html';">Admin Panel</button>
    <button id="contactBtn" onclick="window.location.href='support.html';">Support & Contact</button>
    <button class="home-btn" onclick="window.location.href='index.html';">🏠 Home</button>
  </div>
</div>

<div class="main-product-layout">

    <div class="product-info-and-reviews">
        <div class="product-detail" id="productDetail">
            </div>

        <div class="review-section">
            <h3>Customer Reviews</h3>
            <div class="average-rating">
                <span class="score" id="averageRatingValue">0.0</span>
                <span class="stars" id="averageStarDisplay">
                    </span>
                <span class="count" id="reviewCount">(0 reviews)</span>
            </div>
            <div class="recent-reviews">
                <h4>Recent Reviews</h4>
                <ul id="recentReviewsList">
                    <p class="no-reviews-message">Loading reviews...</p>
                </ul>
            </div>
        </div>
    </div>

    <div class="order-form" id="orderForm">
        <h3>🛒 Complete Your Order 🛍️</h3>
        <form id="form">
            <label for="name">👤 Full Name:</label>
            <input type="text" id="name" required>

            <label for="address">🏠 Shipping Address:</label>
            <input type="text" id="address" required>
            <label for="city">🌆 City:</label>
            <input type="text" id="city" required>
            <label for="state">🏙️ State:</label>
            <input type="text" id="state" required>
            <label for="region">🌍 Region:</label>
            <input type="text" id="region" required>
            <label for="zip">💳 Zip Code:</label>
            <input type="text" id="zip" required>
            <label for="quantity">🔢 Quantity:</label>
            <input type="number" id="quantity" min="1"
                value="1" required>

            <div class="payment-methods-section">
                <h3>Payment Methods</h3>

                <div>
                    <input type="checkbox" id="includeMarketFee">
                    <label for="includeMarketFee" class="checkbox-label">Include 0.5% Market Creator Fee</label>
                    <i class="fas fa-info-circle info-icon" id="marketFeeInfoIcon"></i>
                </div>
                <p class="market-fee-text" id="marketFeeText">
                    (By contributing this fee, you help the market potentially live on for future generations.)
                </p>

                <button type="button" id="submitPaymentBtn">💳 Pay with Crypto</button>

                <button type="button" class="alt-pay-button" id="payWithVenmoBtn" onclick="window.location.href='YOUR_VENMO_PAYMENT_LINK';">📱 Pay with Venmo</button>
                <button type="button" class="alt-pay-button" id="payWithCashAppBtn" onclick="window.location.href='YOUR_CASHAPP_PAYMENT_LINK';">💸 Pay with Cash App</button>
                <button type="button" class="alt-pay-button" id="payWithPaypalBtn" onclick="window.location.href='YOUR_PAYPAL_PAYMENT_LINK';">🅿️ Pay with PayPal</button>
                <button type="button" class="alt-pay-button" id="payWithGooglePayBtn" onclick="window.location.href='YOUR_GOOGLEPAY_PAYMENT_LINK';">💳 Pay with Google Pay</button>
                <button type="button" class="alt-pay-button" id="payWithApplePayBtn" onclick="window.location.href='YOUR_APPLEPAY_PAYMENT_LINK';"> Pay with Apple Pay</button>
            </div>
        </form>
    </div>
</div>


<footer>&copy;
	2025 Universal Crypto Marketplace. All Rights Reserved.</footer>
<script>
  // Firebase Configuration
  // You MUST replace this with your project's actual configuration.
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY", // Replace with your API Key
    authDomain: "YOUR_AUTH_DOMAIN", // Replace with your Auth Domain
    projectId: "YOUR_PROJECT_ID", // Replace with your Project ID
    storageBucket: "YOUR_STORAGE_BUCKET", // Replace with your Storage Bucket
    messagingSenderId: "YOUR_MESSAGING_SENDER_ID", // Replace with your Messaging Sender ID
    appId: "YOUR_APP_ID" // Replace with your App ID
  };

  // Initialize Firebase
  if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
  } else {
      firebase.app(); // if already initialized, use that app
  }

  // Get a reference to the Firestore database
  const db = firebase.firestore();

  let userAccount = null;
  let provider;
  let signer;
  let ethToUsd = 0;
  const ADMIN_WALLET = "0xREPLACEWALLETADMINWALLETNONEEDTOWORRYABOUTFRONTHOMEPAGEUSEWALLETLIKEAGPGTHATTELLSADMINOWNER"; // Replace with your actual admin wallet for the home page check

  // *** Market Creator Wallet Address ***
  const MARKET_CREATOR_WALLET = "0xREPLACE_WITH_MARKET_CREATOR_WALLET_ADDRESS"; // <<< REPLACE with the actual wallet address for the market creator fee

  async function fetchEthToUsd() {
    try {
      const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
      const data = await res.json();
      ethToUsd = data.ethereum.usd;
      // Call function to display product after price is fetched
      displayProductDetail();
    } catch (err) {
      console.error('Failed to fetch ETH to USD:', err);
       // Still attempt to display product even if price fetch fails
      displayProductDetail();
    }
  }

  async function connectWallet() {
    if (window.ethereum) {
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        // Request accounts - this will prompt the user if not already connected
        const accounts = await provider.send("eth_requestAccounts", []); // Use send for explicit request
        signer = provider.getSigner();
        if (accounts.length > 0) {
            updateWalletDisplay(accounts[0]);
            localStorage.setItem('walletAddress', accounts[0]); // Store connected wallet
            // Add event listeners for account/chain changes after successful connection
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
        } else {
            console.log("No accounts returned after request.");
            disconnectWallet(); // Treat as disconnected if no accounts found
            alert('Please select an account in your wallet.');
        }
      } catch (error) {
          console.error("Error connecting wallet:", error);
          alert('Error connecting wallet: ' + error.message);
          disconnectWallet(); // Ensure UI is clean on error
      }
    } else {
      alert('Please install MetaMask or OKX Wallet!');
    }
  }

  async function updateWalletDisplay(account) {
    userAccount = account;
    // Check if provider and signer are initialized before accessing signer
    if (provider) {
        signer = provider.getSigner();
    }
    const walletDisplay = document.getElementById('walletDisplay');
    const connectBtn = document.getElementById('connectBtn');
    const adminBtn = document.getElementById('adminBtn');


    if (userAccount) {
      const short = userAccount.slice(0, 6) + "..." + userAccount.slice(-4);
      walletDisplay.textContent = `Wallet: ${short}`;
      connectBtn.textContent = '✅ Connected'; // Changed text

      if (userAccount.toLowerCase() === ADMIN_WALLET.toLowerCase()) {
        adminBtn.style.display = 'inline-block';
      } else {
        adminBtn.style.display = 'none';
      }
    } else {
      // Wallet is disconnected
      walletDisplay.textContent = 'Wallet: —';
      connectBtn.textContent = '🔌 Connect Wallet';
      adminBtn.style.display = 'none';
    }
  }

  function disconnectWallet() {
    userAccount = null;
    signer = null;
    provider = null; // Clear provider as well
    document.getElementById('walletDisplay').textContent = 'Wallet: —';
    document.getElementById('connectBtn').textContent = '🔌 Connect Wallet';
    document.getElementById('adminBtn').style.display = 'none';
    localStorage.removeItem('walletAddress');
     // Remove event listeners on disconnect
     if (window.ethereum) {
         window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
         window.ethereum.removeListener('chainChanged', handleChainChanged);
     }
  }

  document.getElementById('connectBtn').addEventListener('click', async () => {
    if (userAccount) {
      // If a wallet is already connected in our UI, clicking the button disconnects the UI display
      // This provides a simple toggle functionality for the Connect/Disconnect button text
      disconnectWallet();
    } else {
      // If no wallet is connected in our UI, clicking the button initiates connection
      await connectWallet();
    }
  });

    // Handle accounts changed event
    function handleAccountsChanged(accounts) {
        console.log('Accounts changed:', accounts);
        if (accounts.length === 0) {
            // Wallet locked or no accounts connected
            console.log('Wallet disconnected or accounts removed.');
            disconnectWallet(); // Treat as disconnected in the UI
            alert('Wallet disconnected. Please connect again.');
        } else if (accounts[0].toLowerCase() !== userAccount?.toLowerCase()) {
            // Account changed - update display and potentially reload data if needed
            console.log('Account changed to:', accounts[0]);
            updateWalletDisplay(accounts[0]); // Update UI with new account
            localStorage.setItem('walletAddress', accounts[0]); // Store new connected wallet
            // In a product page, account change might not require a full product reload,
            // but it's good practice to update the display and ensure the correct signer is used for transactions.
            // If any part of the product display or order form depends on the *connected* user (not the seller),
            // you might need to update those sections here.
        }
    }

    // Handle chain changed event
    function handleChainChanged(chainId) {
      console.log('Chain changed to:', chainId);
      // A simple approach is to prompt the user to reload the page
      alert('Ethereum network changed. Please reload the page.');
       window.location.reload(); // Force a reload
    }


  // Function to get product ID from URL
  function getProductIdFromUrl() {
    const params = new URLSearchParams(window.location.search);
    return params.get('id');
  }

  // Function to display product details (FETCHING FROM FIRESTORE)
  async function displayProductDetail() {
      const productId = getProductIdFromUrl();
      const productDetailDiv = document.getElementById('productDetail');
      productDetailDiv.innerHTML = '<p>Loading product details...</p>'; // Loading indicator

      if (!productId) {
          productDetailDiv.innerHTML = '<p style="color: red;">Product ID not found in URL.</p>';
          return;
      }

      try {
          // Fetch product from Firestore by ID
          const doc = await db.collection('products').doc(productId).get();

          if (!doc.exists) {
              productDetailDiv.innerHTML = '<p style="color: red;">Product not found.</p>';
              return;
          }

          const product = doc.data();
          const usdValue = ethToUsd > 0 ? (parseFloat(product.ethPrice) * ethToUsd).toFixed(2) : 'N/A'; // Ensure ethPrice is treated as number

          // Display social media/NFT info if available
          let socialNftHtml = '';
          // Check for instagramUrl, tiktokUrl, otherLinkUrl, linkTitle, linkDetails
           if (product.instagramUrl) {
               socialNftHtml += `<p><strong>Instagram:</strong> <a href="${product.instagramUrl}" target="_blank">${product.instagramUrl}</a></p>`;
           }
            if (product.tiktokUrl) {
                socialNftHtml += `<p><strong>TikTok:</strong> <a href="${product.tiktokUrl}" target="_blank">${product.tiktokUrl}</a></p>`;
            }
             if (product.otherLinkUrl) {
                 socialNftHtml += `<p><strong>${product.linkTitle || 'External Link'}:</strong> <a href="${product.otherLinkUrl}" target="_blank">${product.otherLinkUrl}</a></p>`;
                  if (product.linkDetails) {
                      socialNftHtml += `<p style="font-size: 0.9em; color: #555; margin-top: -10px; margin-bottom: 10px;">${product.linkDetails}</p>`;
                  }
             }


          if (product.nftContractAddress && product.nftTokenId) {
               socialNftHtml += `<p><strong>NFT Details:</strong> Contract: ${product.nftContractAddress.substring(0, 6)}..., Token ID: ${product.nftTokenId}</p>`;
               // You would typically add logic here to fetch more NFT details using an API
          }

          productDetailDiv.innerHTML = `
              <img src="${product.imageUrl || 'placeholder-image.png'}" alt="${product.name}" />
              <h3>${product.name}</h3>
              <p>${product.description}</p>
              <p><strong>Keywords:</strong> ${product.keywords ? product.keywords.join(', ') : 'None'}</p>
              <p class="price">${product.ethPrice} ETH ${ethToUsd > 0 ? '(~$' + usdValue + ')' : ''}</p>
              ${socialNftHtml}
          `;

          // Store current product details for order processing
          productDetailDiv.dataset.productName = product.name;
          productDetailDiv.dataset.ethPrice = product.ethPrice;
           // Store seller wallet for payment
          productDetailDiv.dataset.sellerWallet = product.sellerWallet;

          // Load reviews for this product after product details are displayed
          loadProductReviews(productId);


      } catch (error) {
          console.error("Error fetching product details:", error);
          productDetailDiv.innerHTML = '<p style="color: red;">Error loading product details.</p>';
      }
  }

    // Function to render stars for a given rating (used for average and individual reviews)
    function renderStars(rating) {
        let starsHTML = '';
        const roundedRating = Math.round(rating); // Round to nearest whole star for display
        for (let i = 0; i < 5; i++) {
            if (i < roundedRating) {
                starsHTML += '<i class="fas fa-star"></i>'; // Filled star
            } else {
                starsHTML += '<i class="far fa-star"></i>'; // Empty star
            }
        }
        return starsHTML;
    }


    // Function to load reviews for the current product
    async function loadProductReviews(productId) {
        const recentReviewsList = document.getElementById('recentReviewsList');
        const averageRatingValueSpan = document.getElementById('averageRatingValue');
        const averageStarDisplayDiv = document.getElementById('averageStarDisplay');
        const reviewCountSpan = document.getElementById('reviewCount');

        recentReviewsList.innerHTML = '<p class="no-reviews-message">Loading reviews...</p>'; // Loading indicator
        averageRatingValueSpan.textContent = '0.0';
        averageStarDisplayDiv.innerHTML = renderStars(0); // Display 0 stars initially
        reviewCountSpan.textContent = '(0 reviews)';


        if (!productId) {
            recentReviewsList.innerHTML = '<p class="no-reviews-message">Cannot load reviews without a product ID.</p>';
            return;
        }

        try {
            // Fetch reviews where 'productId' matches the current product's ID
            const snapshot = await db.collection('reviews')
                .where('productId', '==', productId)
                .orderBy('timestamp', 'desc')
                .get();

            const reviews = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            recentReviewsList.innerHTML = ''; // Clear current list

            let totalRating = 0;
            reviews.forEach(review => {
                if (review.rating) {
                    totalRating += review.rating;
                }
            });

            const reviewCount = reviews.length;
            const averageRating = reviewCount > 0 ? (totalRating / reviewCount) : 0;

            // Display average rating
            averageRatingValueSpan.textContent = averageRating.toFixed(1); // Show one decimal place
            averageStarDisplayDiv.innerHTML = renderStars(averageRating); // Render stars for the average
            reviewCountSpan.textContent = `(${reviewCount} review${reviewCount === 1 ? '' : 's'})`;


            if (reviews.length === 0) {
                recentReviewsList.innerHTML = '<p class="no-reviews-message">No reviews yet for this product.</p>';
                return;
            }

            // Display individual reviews
            reviews.forEach(review => {
                const li = document.createElement('li');
                const reviewerShort = review.reviewerWallet ? review.reviewerWallet.slice(0, 6) + '...' + review.reviewerWallet.slice(-4) : 'Anonymous';
                const reviewDate = review.timestamp ? new Date(review.timestamp.toDate()).toLocaleString() : 'N/A';
                const individualStarsHTML = renderStars(review.rating || 0); // Render stars for individual review

                li.innerHTML = `
                    <div class="review-header">
                        <span class="reviewer">${reviewerShort}</span>
                        <span class="review-date">${reviewDate}</span>
                    </div>
                    <div class="review-rating">${individualStarsHTML}</div>
                    <p>${review.reviewText || 'No review text provided.'}</p>
                `;
                recentReviewsList.appendChild(li);
            });

            console.log("Loaded reviews for product:", productId, "Count:", reviewCount, "Average Rating:", averageRating.toFixed(1));

        } catch (error) {
            console.error("Error loading product reviews:", error);
            recentReviewsList.innerHTML = '<p class="no-reviews-message" style="color: red;">Error loading reviews.</p>';
             // Reset average rating display on error
            averageRatingValueSpan.textContent = '0.0';
            averageStarDisplayDiv.innerHTML = renderStars(0);
            reviewCountSpan.textContent = '(Error loading reviews)';
        }
    }


  // Handle Crypto Payment (Includes Optional Market Fee Logic)
  document.getElementById('submitPaymentBtn').addEventListener('click', async () => {
      if (!userAccount) {
          alert("Please connect your wallet to make a purchase.");
          return;
      }

      const productName = document.getElementById('productDetail').dataset.productName;
      const ethPrice = parseFloat(document.getElementById('productDetail').dataset.ethPrice);
      const sellerWallet = document.getElementById('productDetail').dataset.sellerWallet; // Get seller wallet
      const quantity = parseInt(document.getElementById('quantity').value);
      const totalPriceEth = ethPrice * quantity;

      const includeMarketFee = document.getElementById('includeMarketFee').checked; // Check if the fee checkbox is checked

      let marketFeeEth = 0;
      let sellerAmountEth = totalPriceEth; // By default, seller gets the full amount

      if (includeMarketFee) {
          // Calculate Market Fee (0.5%) only if checkbox is checked
          marketFeeEth = totalPriceEth * 0.005;
          sellerAmountEth = totalPriceEth - marketFeeEth;
      }


      const name = document.getElementById('name').value.trim();
      const address = document.getElementById('address').value.trim();
      const city = document.getElementById('city').value.trim();
      const state = document.getElementById('state').value.trim();
      const region = document.getElementById('region').value.trim();
      const zip = document.getElementById('zip').value.trim();

      if (!name || !address || !city || !state || !region || !zip || quantity <= 0 || isNaN(totalPriceEth)) {
           alert("Please fill in all shipping details and ensure quantity is valid.");
           return;
      }

       if (!sellerWallet) {
           alert("Seller wallet address not available for this product.");
           console.error("Seller wallet missing for product:", getProductIdFromUrl());
           return;
       }

       if (includeMarketFee && (!MARKET_CREATOR_WALLET || MARKET_CREATOR_WALLET === "0xREPLACE_WITH_MARKET_CREATOR_WALLET_ADDRESS")) {
            alert("Market creator wallet address is not configured. Cannot process payment with fee.");
            console.error("MARKET_CREATOR_WALLET is not set.");
            return;
       }


      const shippingInfo = { name, address, city, state, region, zip };

      // --- Web3 Payment Logic ---
      let paymentDescription = `Attempting to pay ${sellerAmountEth.toFixed(4)} ETH to seller for ${quantity} x ${productName}. Shipping to ${city}, ${state}.`;
      if (includeMarketFee) {
          paymentDescription += ` (Including ${marketFeeEth.toFixed(4)} ETH fee to market creator)`;
      }
      alert(paymentDescription);


      try {
          // Transaction 1: Send amount to Seller (always happens)
           console.log(`Sending ${sellerAmountEth.toFixed(4)} ETH to seller: ${sellerWallet}`);
           const sellerTx = await signer.sendTransaction({
             to: sellerWallet, // Send payment to the seller's wallet address
             value: ethers.utils.parseEther(sellerAmountEth.toString()) // Convert ETH amount to Wei
           });
           console.log("Seller transaction sent:", sellerTx.hash);
           alert("Seller payment transaction sent! Waiting for confirmation...");
           await sellerTx.wait(); // Wait for transaction confirmation
           alert("Seller payment successful!");
           console.log("Seller transaction confirmed:", sellerTx.hash);

           // Transaction 2: Send Market Fee to Market Creator (only if checkbox is checked)
           if (includeMarketFee) {
               console.log(`Sending ${marketFeeEth.toFixed(4)} ETH fee to market creator: ${MARKET_CREATOR_WALLET}`);
                const feeTx = await signer.sendTransaction({
                  to: MARKET_CREATOR_WALLET, // Send fee to the market creator's wallet address
                  value: ethers.utils.parseEther(marketFeeEth.toString()) // Convert ETH amount to Wei
                });
                console.log("Market fee transaction sent:", feeTx.hash);
                alert("Market fee transaction sent! Waiting for confirmation...");
                await feeTx.wait(); // Wait for transaction confirmation
                alert("Market fee payment successful!");
                console.log("Market fee transaction confirmed:", feeTx.hash);
           }


          // --- Save Order to Firestore (after successful payment in real app) ---
          const order = {
              productId: getProductIdFromUrl(),
              productName: productName,
              quantity: quantity,
              totalEth: totalPriceEth, // Store the total price before fee deduction
              sellerAmountEth: sellerAmountEth, // Store amount sent to seller
              marketFeeEth: marketFeeEth, // Store market fee amount (will be 0 if not included)
              buyerWallet: userAccount,
              sellerWallet: sellerWallet, // Store seller wallet in the order
              marketCreatorWallet: includeMarketFee ? MARKET_CREATOR_WALLET : null, // Store market creator wallet only if fee was included
              shippingInfo: shippingInfo,
              timestamp: firebase.firestore.FieldValue.serverTimestamp()
          };
          await db.collection('orders').add(order);
          console.log("Order saved to Firestore:", order);
          alert("Payment successful and order saved!"); // Update message after adding Firestore save


          // Clear form or redirect
          document.getElementById('form').reset();

      } catch (error) {
          console.error("Payment failed or Order save failed:", error);
           // Check if the error is a user rejecting the transaction
           if (error.code === 4001) {
               alert("Transaction rejected by user.");
           } else {
               alert("Payment or order saving failed. See console for details.");
           }
      }
      // --- End of Web3 Payment Logic ---
  });

  // Placeholder functions for alternative payment methods
  // These would typically redirect to payment links or open payment apps
  document.getElementById('payWithVenmoBtn').addEventListener('click', () => {
       const productName = document.getElementById('productDetail').dataset.productName;
       const quantity = parseInt(document.getElementById('quantity').value);
       // Note: Dynamic links need server-side generation or API calls
       alert(`Redirecting for Venmo payment for ${quantity} x ${productName}... (Link integration needed)`);
       // Example: window.location.href = 'https://venmo.com/u/YOUR_VENMO_ID?txn=pay&amount=TOTAL_USD_AMOUNT&note=Order for ${productName}';
  });

  document.getElementById('payWithCashAppBtn').addEventListener('click', () => {
       const productName = document.getElementById('productDetail').dataset.productName;
       const quantity = parseInt(document.getElementById('quantity').value);
       alert(`Redirecting for Cash App payment for ${quantity} x ${productName}... (Link integration needed)`);
       // Example: window.location.href = 'https://cash.app/$YOURCASHTAG/TOTAL_USD_AMOUNT';
  });

   document.getElementById('payWithPaypalBtn').addEventListener('click', () => {
       const productName = document.getElementById('productDetail').dataset.productName;
       const quantity = parseInt(document.getElementById('quantity').value);
       alert(`Redirecting for PayPal payment for ${quantity} x ${productName}... (Link integration needed)`);
        // Example: window.location.href = 'https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&business=YOUR_PAYPAL_EMAIL&amount=TOTAL_USD_AMOUNT&item_name=Order for ${productName}';
  });

  // Added Google Pay button listener
   document.getElementById('payWithGooglePayBtn')?.addEventListener('click', () => {
        const productName = document.getElementById('productDetail').dataset.productName;
       const quantity = parseInt(document.getElementById('quantity').value);
       alert(`Initiating Google Pay for ${quantity} x ${productName}... (Integration needed)`);
        // Google Pay requires specific setup and often server-side handling
  });


   document.getElementById('payWithApplePayBtn').addEventListener('click', () => {
        const productName = document.getElementById('productDetail').dataset.productName;
       const quantity = parseInt(document.getElementById('quantity').value);
       alert(`Initiating Apple Pay for ${quantity} x ${productName}... (Integration needed)`);
        // Apple Pay requires specific setup and often server-side handling
  });


  window.addEventListener('load', async () => {
    await fetchEthToUsd(); // Fetch price and then display product

    // --- Wallet Auto-Connection Logic ---
    // This block attempts to automatically connect the wallet if it was previously connected
    // and the browser extension is available and unlocked.
    const storedWallet = localStorage.getItem('walletAddress'); // Check if a wallet address was stored from a previous session
    if (storedWallet && window.ethereum) { // Check if a wallet was stored AND the Ethereum provider is available
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        // Use eth_accounts to check for already connected accounts without prompting the user
        const accounts = await provider.send("eth_accounts", []); // This is the key for non-prompting check

        if (accounts.length > 0 && accounts[0].toLowerCase() === storedWallet.toLowerCase()) {
            // If accounts are found and the first one matches the stored address, assume connected
            signer = provider.getSigner();
            updateWalletDisplay(accounts[0]); // Update UI and button visibility
            console.log("Auto-connected to stored wallet:", accounts[0]);
            // Add listeners for existing connections on load
             window.ethereum.on('accountsChanged', handleAccountsChanged);
             window.ethereum.on('chainChanged', handleChainChanged);
        } else {
            // Stored wallet not found, or wallet is locked/disconnected from this site
            console.log("Stored wallet not found or not connected to this site.");
            localStorage.removeItem('walletAddress'); // Clear stored wallet as it's no longer valid
            updateWalletDisplay(null); // Ensure UI is correct (disconnected state)
        }
      } catch (error) {
         console.error("Error during auto-connection check:", error);
         localStorage.removeItem('walletAddress'); // Clear stored wallet on error
         updateWalletDisplay(null); // Ensure UI is correct on error
      }
    } else {
        // No stored wallet or window.ethereum is not available
        updateWalletDisplay(null); // Ensure UI is correct (disconnected state)
        console.log("No stored wallet or Ethereum provider not found.");
    }
    // --- End of Wallet Auto-Connection Logic ---

    // displayProductDetail is now called within fetchEthToUsd to ensure price is available
  });

  // Toggle visibility of market fee text when info icon is clicked
  document.getElementById('marketFeeInfoIcon')?.addEventListener('click', () => {
      const marketFeeText = document.getElementById('marketFeeText');
      if (marketFeeText) {
          // Toggle display: if it's 'none', make it 'block', otherwise make it 'none'
          marketFeeText.style.display = marketFeeText.style.display === 'none' || marketFeeText.style.display === '' ? 'block' : 'none';
      }
  });


</script>
</body>
</html>
