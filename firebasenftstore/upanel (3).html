<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üîë Seller / Buyer Panel</title>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">


  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background-color: #e0f0ff;
      color: #000;
      padding: 20px;
    }
    .box {
      background-color: #f0f0f0;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    }
    label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }
    input:not([type="checkbox"]), button, textarea, select {
      padding: 8px 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
    textarea {
      resize: vertical;
      height: 100px;
       margin-bottom: 10px;
    }
    button {
      cursor: pointer;
       margin-top: 5px;
       width: auto;
       padding: 10px 15px;
       font-weight: bold;
    }
     button.delete-btn {
        background: red;
        color: white;
        border: none;
        margin-left: 10px;
      }
      button.delete-btn:hover {
        background: darkred;
      }

    #statusMessage {
      color: red;
      display: none;
      margin-top: 10px;
    }

    /* Styles for sections visible after wallet connection */
    #connectedContent {
        display: none; /* Hidden by default */
    }

      /* Green button style (used for the Home button and Tax Portal) */
         .green-button {
             background-color: #4CAF50;
             color: white;
             padding: 10px 15px;
             border: none;
             border-radius: 5px;
             cursor: pointer;
             font-size: 16px;
         }
         .green-button:hover {
             background-color: #45a049;
         }

       /* Style for the Tax Portal button */
       .tax-portal-button {
          margin-top: 0;
          width: 100%;
          display: block;
       }

         /* Order List Styling */
         #orderList {
             list-style: none;
             padding: 0;
         }
         #orderList li {
             border-bottom: 1px solid #ccc;
             padding: 10px 0;
             margin-bottom: 10px;
         }
          #orderList li:last-child {
              border-bottom: none;
              margin-bottom: 0;
          }

          /* Support Message List Styling */
          #supportMessageList {
              list-style: none;
              padding: 0;
          }
          #supportMessageList li {
              border-bottom: 1px solid #ccc;
              padding: 10px 0;
              margin-bottom: 10px;
          }
           #supportMessageList li:last-child {
               border-bottom: none;
               margin-bottom: 0;
           }

           /* Styles for Product List (if you decide to add it back) */
            #productList {
                margin-top: 20px;
                /* text-align: center; */ /* Align left for list items */
            }
            .product-item {
                border: 1px solid #ccc;
                padding: 10px;
                margin-bottom: 10px;
                border-radius: 5px;
                background-color: #fff;
                display: flex;
                align-items: center;
                gap: 15px;
                word-break: break-word;
            }
             .product-item img {
                width: 60px;
                height: auto;
                border-radius: 4px;
            }
             .product-details {
                 flex-grow: 1;
             }
              .product-details h4 {
                 margin: 0 0 5px 0;
              }
               .product-details p {
                  margin: 0 0 3px 0;
                  font-size: 0.9em;
                  color: #555;
               }
                .product-details a {
                   color: #0073e6;
                   text-decoration: none;
                }
                 .product-details a:hover {
                    text-decoration: underline;
                 }

        /* Style for the save confirmation message */
        #saveStatusMessage {
            color: green;
            margin-top: 10px;
            font-weight: bold;
            display: none; /* Hidden by default */
        }

        /* Styles for the Review Section (Seller) */
        .review-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
         .review-section h3 {
             border-bottom: 2px solid #ffc107; /* Yellow border for reviews */
             padding-bottom: 10px;
             margin-bottom: 15px;
         }
        .average-rating {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            font-size: 1.5em;
            color: #ffc107; /* Yellow color for stars */
        }
        .average-rating .stars {
            margin-right: 10px;
        }
         .average-rating .stars i {
             color: #ffc107; /* Ensure stars are yellow */
         }
        .average-rating .score {
            font-weight: bold;
            margin-right: 5px;
            color: #333; /* Darker color for the score */
        }
        .average-rating .count {
            font-size: 0.8em;
            color: #555;
        }
         .recent-reviews h4 {
             font-size: 1.2em;
             margin-bottom: 10px;
             border-bottom: 1px solid #eee;
             padding-bottom: 5px;
         }
        #sellerReviewList {
            list-style: none;
            padding: 0;
        }
        #sellerReviewList li {
            border: 1px solid #eee;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
         #sellerReviewList li:last-child {
             margin-bottom: 0;
         }
         #sellerReviewList li .review-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 5px;
         }
          #sellerReviewList li .review-header .reviewer {
              font-weight: bold;
              color: #0073e6;
              font-size: 0.9em;
          }
           #sellerReviewList li .review-header .review-date {
               font-size: 0.8em;
               color: #777;
           }
         #sellerReviewList li .review-rating i {
             color: #ffc107;
             font-size: 0.9em;
         }
        #sellerReviewList li p {
            margin: 0;
            color: #444;
            font-size: 0.9em;
        }
         .no-data-message { /* Reused class for consistency */
             font-style: italic;
             color: #777;
         }

        /* Styles for Buyer Panel Section */
        .buyer-panel-section {
             margin-top: 20px;
             padding-top: 15px;
             border-top: 1px solid #ddd;
        }
         .buyer-panel-section h3 {
             border-bottom: 2px solid #0073e6; /* Blue border for buyer section */
             padding-bottom: 10px;
             margin-bottom: 15px;
         }
         .buyer-panel-section .embedded-list-item .item-details button {
             width: auto; /* Allow button to size based on content */
             padding: 5px 10px;
             font-size: 0.9em;
             margin-top: 5px;
             background-color: #f39c12; /* Orange for review button */
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
         }
          .buyer-panel-section .embedded-list-item .item-details button:hover {
              background-color: #e67e22; /* Darker orange on hover */
          }

  </style>
</head>
<body>
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <h1 style="margin: 0;">üîë Seller / Buyer Panel</h1>
    <button onclick="location.href='index.html'" class="green-button">üè† Home</button>
  </div>

  <div class="box">
    <h2>üåê Connect Your Wallet</h2>
    <p>Connect your wallet (e.g., MetaMask, OKX Wallet) to access your dashboard.</p>
    <button id="connectWalletBtn" class="green-button">üîó Connect Wallet</button>
     <p id="statusMessage" style="color: red;">Please connect your wallet to continue.</p>
     <p id="connectedWalletAddress" style="display: none; margin-top: 10px; font-size: 12px;">
  ‚úÖ Connected Wallet: <span id="walletDisplay" style="font-size: 12px; word-break: break-word;"></span>
</p>
  </div>

  <div class="box" id="regionBox">
    <h2>üåç Your Region</h2>
    <p>Your detected region for tax calculations and compliance.</p>
    <p id="regionOutput">Detecting region...</p>
  </div>

  <div id="connectedContent">

    <div class="box">
       <h2>üì¶ Add/Manage Products (Seller)</h2>

       <h3>Add a New Product (Standard)</h3>
       <label>üìù Product Name: <input id="productName" /></label>
       <label>üßæ Description: <textarea id="productDescription"></textarea></label>
       <label>üîë SEO Keywords (comma-separated): <input id="productKeywords" /></label>
       <label>üí∞ ETH Price: <input id="ethPrice" type="number" step="any" /></label>
       <label>üíµ USD Equivalent: <input id="usdPrice" readonly /></label>
       <label>üóÇÔ∏è Upload Image: <input type="file" id="productImageFile" accept="image/*" /></label>

       <hr style="margin: 20px 0;">

       <h3>Add an NFT Listing (Optional)</h3>
       <p>Fill these fields instead of/in addition to the above if listing an NFT.</p>
       <label>üîó NFT Contract Address: <input id="nftContractAddress" placeholder="0x..." /></label>
       <label>üÜî NFT Token ID: <input id="nftTokenId" type="number" step="1" /></label>
        <label>üîë SEO Keywords (comma-separated): <input id="nftKeywords" /></label>
         <label>üí∞ ETH Price: <input id="nftEthPrice" type="number" step="any" /></label>
         <label>üíµ USD Equivalent: <input id="nftUsdPrice" readonly /></label>

        <hr style="margin: 20px 0;">

        <h4>Lazy List on Marketplace (Requires Integration)</h4>
        <p>To list an NFT with lazy gas fees, you need to integrate with a specific NFT marketplace API that supports this feature.</p>
        <button onclick="alert('Lazy listing requires integration with a marketplace API (e.g., OpenSea, Rarible) and wallet signing. This functionality is not yet implemented.')" class="green-button">‚ú® Lazy List NFT</button>
        <p style="font-size: 0.9em; color: #555; margin-top: 5px;">*This button is a placeholder. Actual implementation needs marketplace API calls and wallet signing.</p>


       <hr style="margin: 20px 0;">

       <h3>Add Social Media/External Links (Optional)</h3>
       <label>üì∑ Instagram URL: <input id="instagramUrl" placeholder="https://www.instagram.com/..." /></label>
       <label>üï∫ TikTok URL: <input id="tiktokUrl" placeholder="https://www.tiktok.com/@..." /></label>
       <label>üåê Other Link: <input id="otherLinkUrl" placeholder="https://..." /></label>
        <label>üìù Link Title: <input id="linkTitle" placeholder="e.g., Artist Website" /></label>
        <label>üìã Link Details: <textarea id="linkDetails" placeholder="Brief description of the link..."></textarea></label>
        <label>üîë SEO Keywords (comma-separated): <input id="socialLinkKeywords" /></label>
        <label>üí∞ ETH Price: <input id="socialLinkEthPrice" type="number" step="any" /></label>
        <label>üíµ USD Equivalent: <input id="socialLinkUsdPrice" readonly /></label>


       <button id="addProductBtn" class="green-button">‚ûï Add Product</button>
       <button id="clearFieldsBtn" class="connect-btn">üßπ Clear Fields</button>


       <h3 style="margin-top: 30px;">üóÉÔ∏è View Your Product Listings</h3>
       <div id="productList">
            <p>Your product listings are managed and viewed in the Product Database.</p>
            <button onclick="location.href='product_database.html?source=seller'" class="green-button product-database-button">üìÇ Go to Product Database</button>
           </div>
         </div>


    <div class="box">
      <h2>üì¨ Your Orders (as Seller)</h2>
      <button id="orderNotificationBtn">üîî New Orders <span class="notification-counter" id="orderCounter">0</span></button>
      <button id="deleteAllOrdersBtn" class="delete-btn">üóëÔ∏è Delete All Orders</button>
      <p>Total Order Value (Estimate): $<span id="sellerOrderValue">0</span></p>
      <div id="orderListContainer" style="display: none;">
        <h4>Recent Orders for Your Items</h4>
        <ul id="orderList"></ul>
      </div>
    </div>

    <div class="box review-section">
        <h2>‚≠ê Your Product Reviews (as Seller)</h2>
         <div class="average-rating">
            <span class="score" id="sellerAverageRatingValue">0.0</span>
            <span class="stars" id="sellerAverageStarDisplay">
                </span>
            <span class="count" id="sellerReviewCount">(0 reviews)</span>
        </div>
        <div class="recent-reviews">
            <h4>Recent Reviews for Your Products</h4>
            <div id="sellerReviewList" class="embedded-list">
                <p class="no-data-message">Connect wallet to see your reviews.</p>
            </div>
        </div>
    </div>

    <div class="box buyer-panel-section">
        <h2>üõí Your Purchases & Reviews (as Buyer)</h2>

        <h3>Your Recent Purchase Orders</h3>
        <div id="userPurchaseOrdersList" class="embedded-list">
            <p class="no-data-message">Connect wallet to see your purchase history.</p>
        </div>
         <button onclick="window.location.href='purchase_history.html';" class="green-button" style="margin-top: 15px;">View All Purchase History</button>
    </div>


    <div id="supportMessagesContainer" class="box">
      <h2>üí¨ Your Support Messages</h2>
      <div id="supportMessageList" class="embedded-list"></div>
      <button id="deleteAllMessagesBtn" class="delete-btn">üóëÔ∏è Delete All Messages</button>

      </div>

    <div class="box">
        <h2>üìä Taxation</h2>
        <button onclick="location.href='crypto_tax.html'" class="green-button tax-portal-button">üí∞ Tax Portal</button>
    </div>

    <div class="box">
        <h2>üí≥ Your Payment Methods (as Seller)</h2>
        <p>Enter the details buyers can use to pay you via alternative methods.</p>

        <label for="venmoIdentifier">üì± Venmo ID/Link:</label>
        <input type="text" id="venmoIdentifier" placeholder="@YourVenmoID or https://venmo.com/u/..." />

        <label for="cashAppIdentifier">üí∏ Cash App Tag/Link:</label>
        <input type="text" id="cashAppIdentifier" placeholder="$YourCashtag or https://cash.app/$..." />

        <label for="paypalIdentifier">üÖøÔ∏è PayPal Email/Link:</label>
        <input type="text" id="paypalIdentifier" placeholder="your.email@example.com or https://paypal.me/..." />

        <label for="googlePayIdentifier">üí≥ Google Pay Identifier:</label>
        <input type="text" id="googlePayIdentifier" placeholder="Your Google Pay Identifier" />

        <label for="applePayIdentifier">Ô£ø Apple Pay Identifier:</label>
        <input type="text" id="applePayIdentifier" placeholder="Your Apple Pay Identifier" />

        <hr style="margin: 20px 0;"> <h3>üèõÔ∏è Tax Wallet Information</h3>
        <p>Provide a separate wallet address for receiving tax portions of sales.</p>
        <label for="taxWalletAddress">üßæ Tax Wallet Address:</label>
        <input type="text" id="taxWalletAddress" placeholder="0x..." />
         <p style="font-size: 0.9em; color: #555; margin-top: -10px;">(A percentage of sales may be sent to this address for tax purposes user tax wallet is stored in firebase by google admin does not control users funds or tax wallets.)</p>


        <button id="savePaymentInfoBtn" class="green-button">üíæ Save Payment Info</button>

        <p id="saveStatusMessage">Payment information saved successfully!</p>

    </div>


  </div>
<script>
// --- Firebase Configuration: REPLACE WITH YOUR ACTUAL CONFIG ---
// You can find this in your Firebase project settings -> General -> Your apps
const firebaseConfig = {
  apiKey: "YOUR_API_KEY", // Replace with your API Key
  authDomain: "YOUR_AUTH_DOMAIN", // Replace with your Auth Domain
  projectId: "YOUR_PROJECT_ID", // Replace with your Project ID
  storageBucket: "YOUR_STORAGE_BUCKET", // Replace with your Storage Bucket
  messagingSenderId: "YOUR_MESSAGING_SENDER_ID", // Replace with your Messaging Sender ID
  appId: "YOUR_APP_ID" // Replace with your App ID
};

// Initialize Firebase
if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
}
const db = firebase.firestore(); // Firestore reference
const storage = firebase.storage(); // Storage reference (Needed for image uploads)


let ethToUsd = 0; // Variable to store the current ETH to USD rate
let connectedWallet = null; // Variable to store the connected wallet address
let provider; // Ethers provider
let signer;

let currentReviewProductId = null; // To store the product ID for the current review


// Fetch ETH to USD price from CoinGecko API
async function fetchEthUsdPrice() {
  console.log("upanel: Fetching ETH to USD price...");
  try {
    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
    const data = await response.json();
    ethToUsd = parseFloat(data.ethereum.usd);
    console.log("upanel: Fetched ETH to USD rate:", ethToUsd);
    // If wallet is already connected, reload data that depends on price
    if (connectedWallet) {
        loadOrders(connectedWallet); // Load seller orders to update USD values
        loadUserPurchaseOrders(connectedWallet); // Load buyer orders to update USD values
         // Load reviews for seller's products after price is fetched
        loadSellerReviews(connectedWallet);
    }
  } catch (error) {
    console.error('upanel: Error fetching ETH price:', error);
    ethToUsd = 0; // Set to 0 or a fallback on error
     updateUsdFields(); // Still attempt to update fields even on error
  }
}

// Function to update all USD equivalent fields based on their corresponding ETH input
function updateUsdFields() {
     // Update USD for main product ETH price
    const ethInput = document.getElementById('ethPrice');
    const usdOutput = document.getElementById('usdPrice');
    const ethAmount = parseFloat(ethInput?.value);
    if (ethInput && usdOutput) {
        if (!isNaN(ethAmount) && ethToUsd) {
            usdOutput.value = `$${(ethAmount * ethToUsd).toFixed(2)}`;
        } else {
            usdOutput.value = '';
        }
    }

     // Update USD for NFT ETH price
     const nftEthInput = document.getElementById('nftEthPrice');
     const nftUsdOutput = document.getElementById('nftUsdPrice');
     const nftEthAmount = parseFloat(nftEthInput?.value);
     if (nftEthInput && nftUsdOutput) {
         if (!isNaN(nftEthAmount) && ethToUsd) {
             nftUsdOutput.value = `$${(nftEthAmount * ethToUsd).toFixed(2)}`;
         } else {
             nftUsdOutput.value = '';
         }
     }

     // Update USD for Social Link ETH price
     const socialLinkEthInput = document.getElementById('socialLinkEthPrice');
     const socialLinkUsdOutput = document.getElementById('socialLinkUsdPrice');
     const socialLinkEthAmount = parseFloat(socialLinkEthInput?.value);
     if (socialLinkEthInput && socialLinkUsdOutput) {
         if (!isNaN(socialLinkEthAmount) && ethToUsd) {
             socialLinkUsdOutput.value = `$${(socialLinkEthAmount * ethToUsd).toFixed(2)}`;
         } else {
             socialLinkUsdOutput.value = '';
         }
     }
}


// Listen for changes in all ETH price inputs to update their USD equivalent
document.getElementById('ethPrice')?.addEventListener('input', updateUsdFields);
document.getElementById('nftEthPrice')?.addEventListener('input', updateUsdFields);
document.getElementById('socialLinkEthPrice')?.addEventListener('input', updateUsdFields);


// Function to detect region using ipapi.co API

async function detectRegion() {
    const regionOutput = document.getElementById('regionOutput');
    if (!regionOutput) return;

    try {
        const res = await fetch('https://ipwho.is/');
        const data = await res.json();

        if (data.success) {
            const regionText = `IP: ${data.ip} | ${data.city || 'N/A'}, ${data.region || 'N/A'}, ${data.country || 'N/A'}`;
            regionOutput.innerText = regionText;
        } else {
            regionOutput.innerText = 'Could not detect region (API error).';
            console.error('upanel: Region detection API error:', data.message);
        }
    } catch (error) {
        regionOutput.innerText = 'Could not detect region (fetch failed).';
        console.error('upanel: Region detection failed:', error);
    }
}


// --- Product Management Functions (Using Firestore) ---

// Upload image to Firebase Storage
async function uploadImage(file) {
    if (!file) return null;
    const storageRef = storage.ref();
    // Create a unique filename (e.g., using timestamp and original name)
    const filename = `${Date.now()}_${file.name}`;
    const imageRef = storageRef.child(`product_images/${filename}`); // Store in 'product_images' folder
    await imageRef.put(file);
    const downloadURL = await imageRef.getDownloadURL();
    return downloadURL;
}


// Add Product (Saves to Firestore with connectedWallet)
async function addProduct() {
    if (!connectedWallet) {
        alert("Please connect your wallet to list a product.");
        return;
    }

    const name = document.getElementById('productName').value.trim();
    const description = document.getElementById('productDescription').value.trim();

    // Keywords from all sections
    const productKeywords = document.getElementById('productKeywords').value.trim().split(',').map(k => k.trim()).filter(k => k !== '');
    const nftKeywords = document.getElementById('nftKeywords').value.trim().split(',').map(k => k.trim()).filter(k => k !== '');
    const socialLinkKeywords = document.getElementById('socialLinkKeywords').value.trim().split(',').map(k => k.trim()).filter(k => k !== '');
    const allKeywords = [...productKeywords, ...nftKeywords, ...socialLinkKeywords]; // Combine keywords

    // Prices from all sections (prioritize standard, then NFT, then social link if multiple entered)
    const ethPriceMain = parseFloat(document.getElementById('ethPrice').value);
    const ethPriceNft = parseFloat(document.getElementById('nftEthPrice').value);
    const ethPriceSocial = parseFloat(document.getElementById('socialLinkEthPrice').value);

     let finalEthPrice = null;
     if (!isNaN(ethPriceMain)) {
         finalEthPrice = ethPriceMain;
     } else if (!isNaN(ethPriceNft)) {
         finalEthPrice = nftEthPrice;
     } else if (!isNaN(ethPriceSocial)) {
         finalEthPrice = socialLinkEthPrice;
     }


    const imageFile = document.getElementById('productImageFile').files[0];

    // NFT Fields
    const nftContractAddress = document.getElementById('nftContractAddress').value.trim();
    const nftTokenId = document.getElementById('nftTokenId').value.trim();

    // Social Media Links
    const instagramUrl = document.getElementById('instagramUrl').value.trim();
    const tiktokUrl = document.getElementById('tiktokUrl').value.trim();
    const otherLinkUrl = document.getElementById('otherLinkUrl').value.trim();
    const linkTitle = document.getElementById('linkTitle').value.trim();
    const linkDetails = document.getElementById('linkDetails').value.trim();


    // Basic validation
    if (!name || !description) {
        alert('Please fill in Product Name and Description.');
        return;
    }
     // Validate if at least one price OR NFT details are provided
     if (isNaN(finalEthPrice) && (!nftContractAddress || !nftTokenId)) {
         alert('Please enter an ETH Price (in any section) or fill in NFT Contract Address and Token ID.');
         return;
      }
      // Validation for conflicting input (basic) - Prevent image upload if NFT details are provided
      if (imageFile && (nftContractAddress || nftTokenId)) {
           alert('Please list either a standard product with image OR an NFT. Do not upload an image if listing an NFT.');
           return;
      }

      // Basic NFT format validation (can be improved with regex)
      if (nftContractAddress && !ethers.utils.isAddress(nftContractAddress)) {
          alert('Invalid NFT Contract Address format.');
          return;
      }
       if (nftTokenId && isNaN(parseInt(nftTokenId))) {
           alert('Invalid NFT Token ID. Must be a number.');
           return;
        }


    let imageUrl = null;
    if (imageFile) {
        // Upload image if it's a standard product with an image
        imageUrl = await uploadImage(imageFile);
    }
     // Note: For NFTs, you would typically fetch the image URL from metadata
     // using the contract address and token ID here. This is NOT implemented.


    const productData = {
        name: name,
        description: description,
        keywords: allKeywords, // Save combined keywords
        ethPrice: finalEthPrice, // Save the determined ETH price
        imageUrl: imageUrl, // Store image URL from upload

        // NFT Data (Store if provided)
        nftContractAddress: nftContractAddress || null,
        nftTokenId: nftTokenId || null,
        // nftMetadataUrl: '...' // You would ideally store a URL to NFT metadata here

        // Social Media Links (Store if provided)
        instagramUrl: instagramUrl || null,
        tiktokUrl: tiktokUrl || null,
        otherLinkUrl: otherLinkUrl || null,
        linkTitle: linkTitle || null, // New: Link Title
        linkDetails: linkDetails || null, // New: Link Details
         // Add other social media fields here

        sellerWallet: connectedWallet.toLowerCase(), // Associate product with the connected seller's wallet
        timestamp: firebase.firestore.FieldValue.serverTimestamp() // Add server timestamp
    };

    try {
        // Add the product data to the 'products' collection in Firestore
        await db.collection('products').add(productData);
        alert('Product added successfully!');
        clearFields(); // Clear form fields after successful addition
    } catch (error) {
        console.error("upanel: Error adding product:", error);
        alert('Error adding product: ' + error.message);
    }
}


// Clear form fields
function clearFields() {
    document.getElementById('productName').value = '';
    document.getElementById('productDescription').value = '';

    document.getElementById('productKeywords').value = '';
    document.getElementById('ethPrice').value = '';
    document.getElementById('usdPrice').value = '';
    document.getElementById('productImageFile').value = ''; // Clear file input

    document.getElementById('nftContractAddress').value = '';
    document.getElementById('nftTokenId').value = '';
    document.getElementById('nftKeywords').value = '';
    document.getElementById('nftEthPrice').value = '';
    document.getElementById('nftUsdPrice').value = '';

    document.getElementById('instagramUrl').value = '';
    document.getElementById('tiktokUrl').value = '';
    document.getElementById('otherLinkUrl').value = '';
    document.getElementById('linkTitle').value = '';
    document.getElementById('linkDetails').value = '';
    document.getElementById('socialLinkKeywords').value = '';
    document.getElementById('socialLinkEthPrice').value = '';
    document.getElementById('socialLinkUsdPrice').value = '';
    // Clear other social media fields
}


// --- Payment Info Functions (Using Firestore) ---

// Function to save payment addresses and tax wallet to Firestore for the connected wallet
async function savePaymentInfo() {
    if (!connectedWallet) {
        alert("Please connect your wallet first.");
        return;
    }

    const venmo = document.getElementById('venmoIdentifier').value.trim();
    const cashApp = document.getElementById('cashAppIdentifier').value.trim();
    const paypal = document.getElementById('paypalIdentifier').value.trim();
    const googlePay = document.getElementById('googlePayIdentifier').value.trim();
    const applePay = document.getElementById('applePayIdentifier').value.trim();
    const taxWalletAddress = document.getElementById('taxWalletAddress').value.trim(); // Get tax wallet address

    // Create an object with only the non-empty payment identifiers and the tax wallet
    const paymentDataToSave = {};
    if (venmo) paymentDataToSave.venmo = venmo;
    if (cashApp) paymentDataToSave.cashApp = cashApp;
    if (paypal) paymentDataToSave.paypal = paypal;
    if (googlePay) paymentDataToSave.googlePay = googlePay;
    if (applePay) paymentDataToSave.applePay = applePay;
    // Always save tax wallet address, even if empty, to clear it if needed
    paymentDataToSave.taxWalletAddress = taxWalletAddress;


    // Add a timestamp
    paymentDataToSave.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();

    // Get the save status message element
    const saveStatusMessage = document.getElementById('saveStatusMessage');
    if (!saveStatusMessage) {
        console.error("upanel: Save status message element not found!");
        alert('Payment information saved successfully!'); // Fallback to alert
        return;
    }

    // Store payment info under a document named by the connected wallet address
    const sellerPaymentInfoRef = db.collection('sellerPaymentInfo').doc(connectedWallet.toLowerCase());

    try {
        // Use merge: true so only the provided fields are updated/added
        await sellerPaymentInfoRef.set(paymentDataToSave, { merge: true });

        // Display the success message
        saveStatusMessage.textContent = 'Payment information saved successfully!';
        saveStatusMessage.style.color = 'green'; // Ensure it's green
        saveStatusMessage.style.display = 'block';

        // Hide the message after 3 seconds
        setTimeout(() => {
            saveStatusMessage.style.display = 'none';
        }, 3000); // 3000 milliseconds = 3 seconds

        // Optional: Keep the alert as well, or remove it if you only want the on-page message
        // alert('Payment information saved successfully!');

    } catch (error) {
        console.error("upanel: Error saving payment info:", error);
        // Display an error message on the page
        saveStatusMessage.textContent = 'Error saving payment information: ' + error.message;
        saveStatusMessage.style.color = 'red'; // Make it red for errors
        saveStatusMessage.style.display = 'block';

         // Hide the error message after 5 seconds (or longer if preferred)
        setTimeout(() => {
            saveStatusMessage.style.display = 'none';
        }, 5000); // 5000 milliseconds = 5 seconds

        // Optional: Keep the alert as well
        // alert('Error saving payment information: ' + error.message);
    }
}

// Function to load payment addresses and tax wallet from Firestore for the connected wallet
async function loadPaymentInfo(walletAddress) {
     if (!walletAddress) return;

     console.log("upanel: Attempting to load payment info for wallet:", walletAddress); // Added log

     // Load payment info from the document named by the connected wallet address
     const sellerPaymentInfoRef = db.collection('sellerPaymentInfo').doc(walletAddress.toLowerCase());

     try {
         const doc = await sellerPaymentInfoRef.get();
         if (doc.exists) {
             const data = doc.data();
             // Populate fields only if the data exists
             document.getElementById('venmoIdentifier').value = data.venmo || '';
             document.getElementById('cashAppIdentifier').value = data.cashApp || '';
             document.getElementById('paypalIdentifier').value = data.paypal || '';
             document.getElementById('googlePayIdentifier').value = data.googlePay || '';
             document.getElementById('applePayIdentifier').value = data.applePay || '';
             document.getElementById('taxWalletAddress').value = data.taxWalletAddress || ''; // Load tax wallet address
             console.log("upanel: Payment information loaded.");
         } else {
             console.log("upanel: No payment information found for this seller.");
             // Clear fields if no data exists for this wallet
             document.getElementById('venmoIdentifier').value = '';
             document.getElementById('cashAppIdentifier').value = '';
             document.getElementById('paypalIdentifier').value = '';
             document.getElementById('googlePayIdentifier').value = '';
             document.getElementById('applePayIdentifier').value = '';
             document.getElementById('taxWalletAddress').value = ''; // Clear tax wallet address field
         }
     } catch (error) {
         console.error("upanel: Error loading payment info:", error);
         // Display an error message on the page if loading fails
         const saveStatusMessage = document.getElementById('saveStatusMessage');
         if (saveStatusMessage) {
             saveStatusMessage.textContent = 'Error loading payment information: ' + error.message;
             saveStatusMessage.style.color = 'red';
             saveStatusMessage.style.display = 'block';
              setTimeout(() => {
                saveStatusMessage.style.display = 'none';
            }, 5000);
         } else {
             alert('Error loading payment information: ' + error.message);
         }
     }
}


// --- Support Messages Functions (Using Firestore) ---

// Load Support Messages from Firestore for the connected wallet
async function loadSupportMessages(walletAddress) {
    const supportList = document.getElementById('supportMessageList');
     if (!supportList || !walletAddress) return; // Exit if elements don't exist or no wallet

    supportList.innerHTML = '<p class="no-data-message">Loading messages...</p>';
    console.log("upanel: Loading support messages for wallet:", walletAddress);

    try {
        // Assuming support messages have a 'sellerWallet' field OR 'buyerWallet' field
        // For upanel, we likely want messages related to items they are selling OR items they bought.
        // This listener currently only fetches messages where the connected wallet is the seller.
        // To get messages where they are the buyer, you'd need another query or a different message structure.
        // For now, keeping it focused on seller support messages as per the existing section title.
        const messagesSnapshot = await db.collection('supportMessages')
                                        .where('sellerWallet', '==', walletAddress.toLowerCase()) // Filter by seller wallet
                                        .orderBy('timestamp', 'desc')
                                        .get();
        const messages = messagesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        supportList.innerHTML = ''; // Clear current list

        if (messages.length === 0) {
            supportList.innerHTML = '<p class="no-data-message">No support messages for your items.</p>';
             console.log("upanel: No support messages found.");
            return;
        }

        messages.forEach(msg => {
            const li = document.createElement('div'); // Use div for better styling flexibility
            li.className = 'embedded-list-item'; // Use existing styling class
             const msgDate = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleString() : 'N/A';
            li.innerHTML = `
                <div class="item-details">
                    <h4>Message from ${msg.name || 'Anonymous'} (${msgDate})</h4>
                    <p>${msg.message || 'No message content'}</p>
                    </div>
            `;
            supportList.appendChild(li);
        });
        console.log("upanel: Support messages loaded:", messages.length);

    } catch (error) {
        console.error("upanel: Error loading support messages:", error);
        supportList.innerHTML = '<p class="no-data-message" style="color: red;">Error loading messages.</p>';
    }
}

// Delete All Support Messages from Firestore for the connected wallet
async function deleteAllMessages() {
     if (!document.getElementById('supportMessageList') || !connectedWallet) {
         alert("Please connect your wallet first.");
         return;
     }

    if (confirm('Are you sure you want to delete all support messages for your items? This cannot be undone.')) {
        try {
            // Delete only messages where sellerWallet matches the connected wallet
            const snapshot = await db.collection('supportMessages')
                                    .where('sellerWallet', '==', connectedWallet.toLowerCase())
                                    .get();
            const batch = db.batch();
            snapshot.docs.forEach((doc) => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            alert('All support messages for your items deleted.');
            loadSupportMessages(connectedWallet); // Refresh the list
        } catch (error) {
            console.error("upanel: Error deleting all messages:", error);
            alert('Error deleting all messages: ' + error.message);
        }
    }
}


// --- Orders Functions (Using Firestore) ---

// Load Orders from Firestore for the connected wallet (as Seller)
async function loadOrders(walletAddress) {
    const orderList = document.getElementById('orderList');
    const orderCounter = document.getElementById('orderCounter');
    const sellerOrderValueSpan = document.getElementById('sellerOrderValue'); // Use the updated ID
     if (!orderList || !orderCounter || !sellerOrderValueSpan || !walletAddress) return; // Exit if elements don't exist or no wallet


    orderList.innerHTML = '<p class="no-data-message">Loading orders...</p>';
    orderCounter.textContent = '...'; // Indicate loading
    console.log("upanel: Loading seller orders for wallet:", walletAddress);

    try {
        // Assuming orders have a 'sellerWallet' field
        const ordersSnapshot = await db.collection('orders')
                                       .where('sellerWallet', '==', walletAddress.toLowerCase()) // Filter by seller wallet
                                       .orderBy('timestamp', 'desc')
                                       .limit(5) // Limit to recent orders
                                       .get();
        const orders = ordersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        orderList.innerHTML = ''; // Clear current list
        orderCounter.textContent = orders.length; // Update counter

        if (orders.length === 0) {
            orderList.innerHTML = '<p class="no-data-message">No recent orders for your items.</p>';
            sellerOrderValueSpan.textContent = '0';
            console.log("upanel: No seller orders found.");
            return;
        }

        let totalOrderValueUsd = 0;

        orders.forEach(order => {
            const li = document.createElement('div'); // Use div for consistency with embedded-list-item
            li.className = 'embedded-list-item'; // Use existing styling class
            const orderDate = order.timestamp ? new Date(order.timestamp.toDate()).toLocaleString() : 'N/A';
            const buyerShort = order.buyerWallet ? order.buyerWallet.slice(0, 6) + '...' + order.buyerWallet.slice(-4) : 'N/A';
             const totalEth = order.totalEth || 0;
             // Calculate USD value using the fetched rate
             const orderValueUsd = ethToUsd ? (totalEth * ethToUsd).toFixed(2) : 'N/A';

             // Add to total if USD value is available and a valid number
             if (ethToUsd && !isNaN(parseFloat(orderValueUsd))) {
                 totalOrderValueUsd += parseFloat(orderValueUsd);
             }


            li.innerHTML = `
                 <div class="item-details">
                  <strong>Order for:</strong> ${order.productName || 'N/A'} (x${order.quantity || 1})<br>
                  <strong>Buyer:</strong> ${buyerShort}<br>
                  <strong>Received:</strong> ${totalEth} ETH ${ethToUsd ? '(~$' + orderValueUsd + ')' : ''}<br>
                  <strong>Date:</strong> ${orderDate}
                  </div>
                  `;
            orderList.appendChild(li);
        });

         // Update total order value display
         sellerOrderValueSpan.textContent = ethToUsd ? totalOrderValueUsd.toFixed(2) : 'N/A';
         console.log("upanel: Seller orders loaded:", orders.length);


    } catch (error) {
        console.error("upanel: Error loading seller orders:", error);
        orderList.innerHTML = '<p class="no-data-message" style="color: red;">Error loading orders.</p>';
        orderCounter.textContent = 'Error';
        sellerOrderValueSpan.textContent = 'Error';
    }
}

// Delete All Orders from Firestore for the connected wallet (as Seller)
async function deleteAllOrders() {
    if (!document.getElementById('orderList') || !connectedWallet) {
        alert("Please connect your wallet first.");
        return;
    }

    if (confirm('Are you sure you want to delete all orders for your items? This cannot be undone.')) {
        try {
            // Delete only orders where sellerWallet matches the connected wallet
            const snapshot = await db.collection('orders')
                                    .where('sellerWallet', '==', connectedWallet.toLowerCase())
                                    .get();
            const batch = db.batch();
            snapshot.docs.forEach((doc) => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            alert('All orders for your items deleted.');
            loadOrders(connectedWallet); // Refresh the list
             loadUserPurchaseOrders(connectedWallet); // Also refresh buyer orders list in case any were deleted
        } catch (error) {
            console.error("upanel: Error deleting all orders:", error);
            alert('Error deleting all orders: ' + error.message);
        }
    }
}


// --- Buyer Orders & Reviews Functions (Using Firestore) ---

// Load Purchase Orders from Firestore for the connected wallet (as Buyer)
async function loadUserPurchaseOrders(walletAddress) {
    const purchaseOrdersList = document.getElementById('userPurchaseOrdersList');
     if (!purchaseOrdersList || !walletAddress) return; // Exit if elements don't exist or no wallet

    purchaseOrdersList.innerHTML = '<p class="no-data-message">Loading your purchase history...</p>'; // Loading indicator
    console.log("upanel: Loading buyer purchase orders for wallet:", walletAddress);


    try {
        // Assuming orders have a 'buyerWallet' field
        const ordersSnapshot = await db.collection('orders')
                                       .where('buyerWallet', '==', walletAddress.toLowerCase()) // Filter by buyer wallet
                                       .orderBy('timestamp', 'desc')
                                       .limit(5) // Limit to recent purchases
                                       .get();
        const orders = ordersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        purchaseOrdersList.innerHTML = ''; // Clear current list

        if (orders.length === 0) {
            purchaseOrdersList.innerHTML = '<p class="no-data-message">You have not purchased any items yet.</p>';
             console.log("upanel: No buyer purchase orders found.");
            return;
        }

        // Fetch product details for each order to display the image (Optional for this view, but good practice)
        // This part is commented out to simplify the upanel view, but you can uncomment if needed.
        // const productPromises = orders.map(order => {
        //     if (order.productId) {
        //         return db.collection('products').doc(order.productId).get();
        //     }
        //     return Promise.resolve(null); // Handle orders without a productId
        // });

        // const productSnapshots = await Promise.all(productPromises);
        // const productsMap = {};
        // productSnapshots.forEach(snapshot => {
        //     if (snapshot && snapshot.exists) {
        //         productsMap[snapshot.id] = snapshot.data();
        //     }
        // });


        orders.forEach(order => {
             // const productData = productsMap[order.productId] || {}; // Get product data for the order
             // Render buyer order item with review button and product image
            purchaseOrdersList.appendChild(renderOrderItem(order, 'buyer'));
        });

         console.log("upanel: User buyer purchase orders loaded:", orders.length);

    } catch (error) {
        console.error("upanel: Error loading user purchase orders:", error);
        purchaseOrdersList.innerHTML = '<p class="no-data-message" style="color: red;">Error loading purchase history.</p>';
    }
}


// Function to render a single order item (can be used for buyer or seller orders)
// Modified to include review button for buyer orders
function renderOrderItem(order, type = 'buyer') { // type can be 'buyer' or 'seller'
     const orderDate = order.timestamp ? new Date(order.timestamp.toDate()).toLocaleString() : 'N/A';
     const quantity = order.quantity || 1;
     const productName = order.productName || 'N/A';
     const buyerWallet = order.buyerWallet || 'N/A';
     const sellerWallet = order.sellerWallet || 'N/A'; // Assuming sellerWallet is stored on order
     const totalEth = order.totalEth || 'N/A'; // Assuming totalEth is stored on order
     const orderValueUsd = ethToUsd ? (parseFloat(totalEth) * ethToUsd).toFixed(2) : 'N/A'; // Calculate USD value


    const itemDiv = document.createElement('div');
    itemDiv.className = 'embedded-list-item';

    let detailsHTML = '';
    if (type === 'buyer') {
        detailsHTML = `
            <h4>Purchased: ${productName} x ${quantity}</h4>
            <p>Total Paid: ${totalEth} ETH ${ethToUsd ? '(~$' + orderValueUsd + ')' : ''}</p>
            <p>Date: ${orderDate}</p>
            <button onclick="promptForReview('${order.productId || order.id}', '${productName}')">Leave Review</button>
             `;
    } else if (type === 'seller') {
         detailsHTML = `
             <h4>Order for: ${productName} x ${quantity}</h4>
             <p>Buyer: ${buyerWallet.slice(0, 6) + '...' + buyerWallet.slice(-4)}</p>
             <p>Received: ${totalEth} ETH ${ethToUsd ? '(~$' + orderValueUsd + ')' : ''}</p>
             <p>Date: ${orderDate}</p>
             `;
    }

    itemDiv.innerHTML = `
         <div class="item-details">
             ${detailsHTML}
         </div>
         `;
     // Add click handler to potentially view order details page (if you create one)
     // itemDiv.style.cursor = 'pointer';
     // itemDiv.onclick = () => { window.location.href = `order_details.html?id=${order.id}`; };

    return itemDiv;
}

// Placeholder function to prompt for a review
function promptForReview(productId, productName) {
    // This is a placeholder. A real implementation would show a modal or navigate to a review page.
    alert(`Leaving a review for "${productName}" (Product ID: ${productId}).\n\nReview submission functionality needs to be implemented.`);
    // You would typically capture rating (e.g., 1-5 stars) and review text here
    // and then save it to a 'reviews' collection in Firestore.
    // Example:
    // const rating = prompt("Enter your rating (1-5):");
    // const reviewText = prompt("Enter your review:");
    // if (rating && reviewText && connectedWallet) {
    //     saveReview(productId, parseInt(rating), reviewText, connectedWallet);
    // } else {
    //     alert("Review cancelled or incomplete.");
    // }
}

// Placeholder function to save a review to Firestore
// async function saveReview(productId, rating, reviewText, reviewerWallet) {
//     try {
//         await db.collection('reviews').add({
//             productId: productId,
//             rating: rating,
//             reviewText: reviewText,
//             reviewerWallet: reviewerWallet.toLowerCase(),
//             timestamp: firebase.firestore.FieldValue.serverTimestamp()
//         });
//         alert('Review submitted successfully!');
//         // Optionally refresh the buyer orders list or reviews list
//         loadUserPurchaseOrders(connectedWallet);
//     } catch (error) {
//         console.error("Error submitting review:", error);
//         alert('Error submitting review: ' + error.message);
//     }
// }


// --- Review Functions (Using Firestore) ---

// Function to render stars for a given rating
function renderStars(rating) {
    let starsHTML = '';
    const roundedRating = Math.round(rating); // Round to nearest whole star for display
    for (let i = 0; i < 5; i++) {
        if (i < roundedRating) {
            starsHTML += '<i class="fas fa-star"></i>'; // Filled star
        } else {
            starsHTML += '<i class="far fa-star"></i>'; // Empty star
        }
    }
    return starsHTML;
}


// Function to load reviews for the seller's products and calculate average
async function loadSellerReviews(sellerWalletAddress) {
    const sellerReviewList = document.getElementById('sellerReviewList');
    const sellerAverageRatingValueSpan = document.getElementById('sellerAverageRatingValue');
    const sellerAverageStarDisplayDiv = document.getElementById('sellerAverageStarDisplay');
    const sellerReviewCountSpan = document.getElementById('sellerReviewCount');

    sellerReviewList.innerHTML = '<p class="no-data-message">Loading reviews...</p>'; // Loading indicator
    sellerAverageRatingValueSpan.textContent = '0.0';
    sellerAverageStarDisplayDiv.innerHTML = renderStars(0); // Display 0 stars initially
    sellerReviewCountSpan.textContent = '(0 reviews)';

    console.log("upanel: Loading seller reviews for wallet:", sellerWalletAddress);

    if (!sellerWalletAddress) {
        sellerReviewList.innerHTML = '<p class="no-data-message">Connect wallet to see your reviews.</p>';
        return;
    }

    try {
        // First, get all product IDs for this seller
        const productsSnapshot = await db.collection('products')
            .where('sellerWallet', '==', sellerWalletAddress.toLowerCase())
            .get();

        const productIds = productsSnapshot.docs.map(doc => doc.id);

        if (productIds.length === 0) {
            sellerReviewList.innerHTML = '<p class="no-data-message">You have no products listed yet.</p>';
             sellerAverageRatingValueSpan.textContent = '0.0';
             sellerAverageStarDisplayDiv.innerHTML = renderStars(0);
             sellerReviewCountSpan.textContent = '(0 reviews)';
             console.log("upanel: No products found for seller, no reviews to load.");
            return;
        }

        // Now, fetch reviews for these product IDs
        // Firestore 'in' query is limited to 10 items. If a seller has more than 10 products,
        // you'd need to make multiple queries or restructure your data.
        // For simplicity here, we'll assume a seller doesn't have an excessive number of products with reviews.
        // A more robust solution might involve storing seller's average rating and review count on the user document.
        const reviewsSnapshot = await db.collection('reviews')
            .where('productId', 'in', productIds)
            .orderBy('timestamp', 'desc')
            .get();

        const reviews = reviewsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        sellerReviewList.innerHTML = ''; // Clear current list

        let totalRating = 0;
        reviews.forEach(review => {
            if (review.rating) {
                totalRating += review.rating;
            }
        });

        const reviewCount = reviews.length;
        const averageRating = reviewCount > 0 ? (totalRating / reviewCount) : 0;

        // Display average rating
        sellerAverageRatingValueSpan.textContent = averageRating.toFixed(1); // Show one decimal place
        sellerAverageStarDisplayDiv.innerHTML = renderStars(averageRating); // Render stars for the average
        sellerReviewCountSpan.textContent = `(${reviewCount} review${reviewCount === 1 ? '' : 's'})`;


        if (reviews.length === 0) {
            sellerReviewList.innerHTML = '<p class="no-data-message">No reviews yet for your products.</p>';
             console.log("upanel: No reviews found for seller products.");
            return;
        }

        // Display individual reviews
        reviews.forEach(review => {
            const li = document.createElement('div'); // Use div for consistency with embedded-list-item
             li.className = 'embedded-list-item'; // Use existing styling class
            const reviewerShort = review.reviewerWallet ? review.reviewerWallet.slice(0, 6) + '...' + review.reviewerWallet.slice(-4) : 'Anonymous';
            const reviewDate = review.timestamp ? new Date(review.timestamp.toDate()).toLocaleString() : 'N/A';
            const individualStarsHTML = renderStars(review.rating || 0); // Render stars for individual review

            li.innerHTML = `
                <div class="item-details">
                    <div class="review-header">
                        <span class="reviewer">${reviewerShort}</span>
                        <span class="review-date">${reviewDate}</span>
                    </div>
                    <div class="review-rating">${individualStarsHTML}</div>
                    <p>${review.reviewText || 'No review text provided.'}</p>
                </div>
            `;
            sellerReviewList.appendChild(li);
        });

        console.log("upanel: Loaded reviews for seller products:", sellerWalletAddress, "Count:", reviewCount, "Average Rating:", averageRating.toFixed(1));

    } catch (error) {
        console.error("upanel: Error loading seller reviews:", error);
        sellerReviewList.innerHTML = '<p class="no-data-message" style="color: red;">Error loading reviews.</p>';
         // Reset average rating display on error
        sellerAverageRatingValueSpan.textContent = '0.0';
        sellerAverageStarDisplayDiv.innerHTML = renderStars(0);
        sellerReviewCountSpan.textContent = '(Error loading reviews)';
    }
}


// --- Wallet Connection Logic ---

async function connectWallet() {
    const statusMessage = document.getElementById('statusMessage');
    const walletDisplay = document.getElementById('walletDisplay');
    const connectedWalletAddressDiv = document.getElementById('connectedWalletAddress');
    const connectedContent = document.getElementById('connectedContent');
    const connectBtn = document.getElementById('connectWalletBtn');


    // Check if MetaMask or similar wallet is installed (includes OKX Wallet)
    if (typeof window.ethereum !== 'undefined') {
        console.log("upanel: window.ethereum detected. Attempting to connect wallet...");
        try {
            // Request account access
            console.log("upanel: Requesting wallet accounts...");
            provider = new ethers.providers.Web3Provider(window.ethereum, "any"); // Initialize provider
            console.log("upanel: Ethers provider initialized.");
            const accounts = await provider.send("eth_requestAccounts", []);
            console.log("upanel: eth_requestAccounts returned:", accounts);

            if (accounts.length > 0) {
                connectedWallet = accounts[0]; // Get the first account
                signer = provider.getSigner(); // Initialize signer
                console.log("upanel: Wallet connected successfully:", connectedWallet);

                // Display connected wallet address
                walletDisplay.textContent = connectedWallet;
                connectedWalletAddressDiv.style.display = 'block';
                statusMessage.style.display = 'none'; // Hide status message on successful connection
                connectBtn.textContent = '‚úÖ Connected'; // Update button text

                // Store connected wallet address in localStorage
                localStorage.setItem('walletAddress', connectedWallet);
                console.log("upanel: Wallet address stored in localStorage:", connectedWallet);


                // Show connected content and load data for this wallet
                connectedContent.style.display = 'block';
                loadOrders(connectedWallet); // Load seller orders
                loadSupportMessages(connectedWallet); // Load support messages
                loadPaymentInfo(connectedWallet); // Load payment info
                loadSellerReviews(connectedWallet); // Load seller's product reviews
                loadUserPurchaseOrders(connectedWallet); // Load buyer purchase orders


                // Add event listeners for account/chain changes after successful connection
               window.ethereum.on('accountsChanged', handleAccountsChanged);
               window.ethereum.on('chainChanged', handleChainChanged);
               console.log("upanel: Wallet event listeners added on manual connect.");


            } else {
               console.log("upanel: eth_requestAccounts returned no accounts.");
               disconnectWallet(); // Treat as disconnected if no accounts found
               alert('Please select an account in your wallet.');
            }
        } catch (error) {
            console.error("upanel: Error connecting wallet:", error);
            statusMessage.textContent = 'Error connecting wallet. ' + error.message;
            statusMessage.style.display = 'block';
            connectedWallet = null; // Clear connected wallet on error
            walletDisplay.textContent = '';
            connectedWalletAddressDiv.style.display = 'none';
            connectBtn.textContent = 'üîå Connect Wallet'; // Reset button text
            // Hide connected content if connection fails
            connectedContent.style.display = 'none';
             localStorage.removeItem('walletAddress'); // Clear stored wallet on connection error
             console.log("upanel: Wallet address removed from localStorage due to connection error.");
        }
    } else {
        // If no injected wallet is found
        console.log("upanel: window.ethereum not found. No Ethereum wallet detected.");
        statusMessage.textContent = 'No Ethereum wallet found (e.g., MetaMask, OKX Wallet). Please install one.';
        statusMessage.style.display = 'block';
        connectedWallet = null;
        walletDisplay.textContent = '';
        connectedWalletAddressDiv.style.display = 'none';
        connectBtn.textContent = 'üîå Connect Wallet'; // Reset button text
        // Hide connected content
        connectedContent.style.display = 'none';
         localStorage.removeItem('walletAddress'); // Ensure no wallet is stored if provider is missing
         console.log("upanel: Wallet address removed from localStorage because window.ethereum was not found.");
    }
}

// Handle accounts changed event
function handleAccountsChanged(accounts) {
    console.log('upanel: Accounts changed event fired:', accounts);
    if (accounts.length === 0) {
        // Wallet locked or no accounts connected
        console.log('upanel: Accounts changed: No accounts found. Disconnecting.');
        disconnectWallet(); // Treat as disconnected in the UI
        alert('Wallet disconnected or accounts removed. Please connect again.');
    } else if (accounts[0].toLowerCase() !== connectedWallet?.toLowerCase()) {
        // Account changed - update display and reload data
        console.log('upanel: Accounts changed: Account changed to:', accounts[0]);
        connectedWallet = accounts[0]; // Update connected wallet
        document.getElementById('walletDisplay').textContent = connectedWallet; // Update display
        localStorage.setItem('walletAddress', connectedWallet); // Update stored wallet
        alert('Account changed. Reloading data for the new account.');
        // Reload data for the new account
        loadOrders(connectedWallet); // Reload seller orders
        loadSupportMessages(connectedWallet); // Reload support messages
        loadPaymentInfo(connectedWallet); // Reload payment info for the new account
        loadSellerReviews(connectedWallet); // Reload seller's product reviews for the new account
        loadUserPurchaseOrders(connectedWallet); // Reload buyer purchase orders for the new account
    } else {
         console.log('upanel: Accounts changed: Account is the same, no action needed.');
    }
}

// Handle chain changed event
function handleChainChanged(chainId) {
  console.log('upanel: Chain changed event fired:', chainId);
  // We should reload the page or re-initialize the provider if the network changes
  console.log('upanel: Chain changed to:', chainId);
  // A simple approach is to prompt the user to reload the page
  alert('Ethereum network changed. Please reload the page.');
   window.location.reload(); // Force a reload
}

// Disconnect wallet
function disconnectWallet() {
  console.log("upanel: Disconnecting wallet display.");
  connectedWallet = null;
  provider = null; // Clear provider and signer
  signer = null;
  if (window.ethereum) {
        // Remove listeners to prevent them from firing after manual disconnect
        // Check if removeListener exists before attempting to remove
        if (window.ethereum.removeListener) {
            window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
            window.ethereum.removeListener('chainChanged', handleChainChanged);
             console.log("upanel: Wallet event listeners removed.");
        }
    }
  document.getElementById('walletDisplay').textContent = ''; // Clear display
  document.getElementById('connectedWalletAddress').style.display = 'none'; // Hide display
  document.getElementById('connectWalletBtn').textContent = 'üîå Connect Wallet'; // Reset button text
  document.getElementById('statusMessage').textContent = 'Please connect your wallet to continue.'; // Show status
  document.getElementById('statusMessage').style.display = 'block';
  document.getElementById('connectedContent').style.display = 'none'; // Hide content
  localStorage.removeItem('walletAddress'); // Clear stored wallet on disconnect
  console.log("upanel: Wallet display disconnected. Wallet address removed from localStorage.");
  // Note: This function only updates the UI and clears variables. The actual wallet connection is managed by the browser extension.

   // Clear review section (Seller) when disconnected
   document.getElementById('sellerReviewList').innerHTML = '<p class="no-data-message">Connect wallet to see your reviews.</p>';
   document.getElementById('sellerAverageRatingValue').textContent = '0.0';
   document.getElementById('sellerAverageStarDisplay').innerHTML = renderStars(0);
   document.getElementById('sellerReviewCount').textContent = '(0 reviews)';

    // Clear payment info fields when disconnected
    document.getElementById('venmoIdentifier').value = '';
    document.getElementById('cashAppIdentifier').value = '';
    document.getElementById('paypalIdentifier').value = '';
    document.getElementById('googlePayIdentifier').value = '';
    document.getElementById('applePayIdentifier').value = '';
    document.getElementById('taxWalletAddress').value = ''; // Clear tax wallet address field

     // Clear support messages when disconnected
    document.getElementById('supportMessageList').innerHTML = '<p class="no-data-message">Connect wallet to see your messages.</p>';

     // Clear buyer orders when disconnected
    document.getElementById('userPurchaseOrdersList').innerHTML = '<p class="no-data-message">Connect wallet to see your purchase history.</p>';


}


// --- Event Listeners and Initialization ---

document.addEventListener('DOMContentLoaded', async () => {
    console.log("upanel: DOMContentLoaded. Starting initialization.");

    // Fetch ETH price on load
    fetchEthUsdPrice();

    // Region Detection on load
    detectRegion();

    // Wallet Connect Button Listener
    document.getElementById('connectWalletBtn')?.addEventListener('click', connectWallet);


    // Add Product button listener
    document.getElementById('addProductBtn')?.addEventListener('click', addProduct);

    // Clear Fields button listener
    document.getElementById('clearFieldsBtn')?.addEventListener('click', clearFields);

    // Save Payment Info button listener
    document.getElementById('savePaymentInfoBtn')?.addEventListener('click', savePaymentInfo);


    // Order Notification button listener (Toggles visibility of seller order list)
    document.getElementById('orderNotificationBtn')?.addEventListener('click', () => {
      const orderListContainer = document.getElementById('orderListContainer');
      if (orderListContainer) {
          const isVisible = orderListContainer.style.display === 'block';
          orderListContainer.style.display = isVisible ? 'none' : 'block';
          // No need to reload here, loadOrders is called on connection or account change
      }
    });

    // Delete All Orders button listener (Seller Orders)
    document.getElementById('deleteAllOrdersBtn')?.addEventListener('click', deleteAllOrders);

    // Delete All Messages button listener (Seller Support Messages)
    document.getElementById('deleteAllMessagesBtn')?.addEventListener('click', deleteAllMessages);


    // Re-add the ETH price input listener for the Add Product sections
    document.getElementById('ethPrice')?.addEventListener('input', updateUsdFields);
    document.getElementById('nftEthPrice')?.addEventListener('input', updateUsdFields);
    document.getElementById('socialLinkEthPrice')?.addEventListener('input', updateUsdFields);


    // Initial display state (hide connected content until wallet is connected)
    document.getElementById('connectedContent').style.display = 'none';
    document.getElementById('statusMessage').style.display = 'block'; // Show initial status message

    // Initial state for lists before connection
    document.getElementById('orderList').innerHTML = '<p class="no-data-message">Connect your wallet to see your orders.</p>'; // Seller orders
    document.getElementById('supportMessageList').innerHTML = '<p class="no-data-message">Connect wallet to see your messages.</p>'; // Seller support messages
     // Initial state for reviews before connection (Seller reviews)
    document.getElementById('sellerReviewList').innerHTML = '<p class="no-data-message">Connect wallet to see your reviews.</p>';
    document.getElementById('sellerAverageRatingValue').textContent = '0.0';
    document.getElementById('sellerAverageStarDisplay').innerHTML = renderStars(0);
    document.getElementById('sellerReviewCount').textContent = '(0 reviews)';

    // Initial state for payment info fields before connection
    document.getElementById('venmoIdentifier').value = '';
    document.getElementById('cashAppIdentifier').value = '';
    document.getElementById('paypalIdentifier').value = '';
    document.getElementById('googlePayIdentifier').value = '';
    document.getElementById('applePayIdentifier').value = '';
    document.getElementById('taxWalletAddress').value = ''; // Clear tax wallet address field

    // Initial state for buyer orders list before connection
    document.getElementById('userPurchaseOrdersList').innerHTML = '<p class="no-data-message">Connect wallet to see your purchase history.</p>';


    // --- Wallet Auto-Connection Logic ---
    // This block attempts to automatically connect the wallet if it was previously connected
    // and the browser extension is available and unlocked.
    const storedWallet = localStorage.getItem('walletAddress'); // Check if a wallet address was stored from a previous session
    console.log("upanel: Stored wallet address in localStorage:", storedWallet);

    if (storedWallet && typeof window.ethereum !== 'undefined') { // Check if a wallet was stored AND the Ethereum provider is available
        console.log("upanel: Stored wallet found and window.ethereum is available. Attempting auto-connection.");
        try {
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            console.log("upanel: Provider initialized for auto-connection.");
            // Use eth_accounts to check for already connected accounts without prompting the user
            const accounts = await provider.send("eth_accounts", []); // This is the key for non-prompting check
            console.log("upanel: eth_accounts returned:", accounts);

            if (accounts.length > 0 && accounts[0].toLowerCase() === storedWallet.toLowerCase()) {
                // If accounts are found and the first one matches the stored address, assume connected
                connectedWallet = accounts[0]; // Update connected wallet variable
                signer = provider.getSigner(); // Initialize signer after getting provider
                updateWalletDisplay(connectedWallet); // Update UI based on wallet
                console.log("upanel: Auto-connected successfully to stored wallet:", connectedWallet);
                // Load all user-specific data after auto-connection
                loadOrders(connectedWallet); // Load seller orders
                loadSupportMessages(connectedWallet); // Load support messages
                loadPaymentInfo(connectedWallet); // Load payment info on auto-connect
                loadSellerReviews(connectedWallet); // Load seller's product reviews on auto-connect
                loadUserPurchaseOrders(connectedWallet); // Load buyer purchase orders on auto-connect


                // Add listeners for existing connections on load
                window.ethereum.on('accountsChanged', handleAccountsChanged);
                window.ethereum.on('chainChanged', handleChainChanged);
                console.log("upanel: Wallet event listeners added on auto-connect.");


            } else {
                // Stored wallet not found, or wallet is locked/disconnected from this site
                console.log("upanel: Auto-connection failed: Stored wallet not found or not connected to this site.");
                localStorage.removeItem('walletAddress'); // Clear stored wallet as it's no longer valid
                updateWalletDisplay(null); // Ensure UI is correct (disconnected state)
            }
        } catch (error) {
            console.error("upanel: Error during auto-connection check:", error);
            localStorage.removeItem('walletAddress'); // Clear stored wallet on error
            updateWalletDisplay(null); // Ensure UI is correct on error
        }
    } else {
        // No stored wallet or window.ethereum is not available
        console.log("upanel: No stored wallet or window.ethereum not available. Cannot auto-connect.");
        updateWalletDisplay(null); // Ensure UI is correct (disconnected state)
    }
    // --- End of Wallet Auto-Connection Logic ---
    console.log("upanel: Initialization complete.");
});


// Function to update the wallet display and button text
function updateWalletDisplay(account) {
    const walletDisplay = document.getElementById('walletDisplay');
    const connectBtn = document.getElementById('connectWalletBtn');
    const connectedWalletAddressDiv = document.getElementById('connectedWalletAddress');


    if (account) {
      const short = account.slice(0, 6) + "..." + account.slice(-4);
      walletDisplay.textContent = account; // Display full address in span
      connectedWalletAddressDiv.style.display = 'block'; // Show the display div
      connectBtn.textContent = '‚úÖ Connected'; // Update button text
      console.log("upanel: Wallet display updated: Connected to", account);
      // You might want to add a button here to disconnect the wallet display if needed
    } else {
        // Wallet is disconnected
        walletDisplay.textContent = ''; // Clear display
        connectedWalletAddressDiv.style.display = 'none'; // Hide the display div
        connectBtn.textContent = 'üîå Connect Wallet'; // Reset button text
        console.log("upanel: Wallet display updated: Disconnected.");
    }
}


</script>
</body>
</html>
